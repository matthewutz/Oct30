<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Browser Battle - Fight for Control</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
        background: #0a0a0a;
        color: #fff;
        overflow: hidden;
        height: 100vh;
        display: flex;
        flex-direction: column;
      }

      .header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 1rem 1.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 100;
      }

      .header h1 {
        font-size: 1.5rem;
        font-weight: 700;
      }

      .control-panel {
        display: flex;
        gap: 1rem;
        align-items: center;
      }

      .control-btn {
        padding: 0.6rem 1.2rem;
        background: rgba(255,255,255,0.2);
        border: 2px solid rgba(255,255,255,0.3);
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 0.9rem;
      }

      .control-btn:hover:not(:disabled) {
        background: rgba(255,255,255,0.3);
        border-color: rgba(255,255,255,0.5);
        transform: translateY(-2px);
      }

      .control-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .control-btn.active {
        background: #4ade80;
        border-color: #4ade80;
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
      }

      .players-list {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .player-badge {
        padding: 0.4rem 0.8rem;
        border-radius: 20px;
        font-size: 0.85rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .player-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: currentColor;
      }

      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative;
        overflow: hidden;
      }

      .url-bar {
        background: #1a1a1a;
        padding: 0.75rem 1rem;
        display: flex;
        gap: 0.5rem;
        align-items: center;
        border-bottom: 2px solid #333;
      }

      .url-input {
        flex: 1;
        padding: 0.6rem 1rem;
        background: #2a2a2a;
        border: 2px solid #444;
        border-radius: 8px;
        color: white;
        font-size: 0.9rem;
        font-family: monospace;
      }

      .url-input:focus {
        outline: none;
        border-color: #667eea;
      }

      .url-input:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .go-btn {
        padding: 0.6rem 1.5rem;
        background: #667eea;
        border: none;
        border-radius: 8px;
        color: white;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s;
      }

      .go-btn:hover:not(:disabled) {
        background: #5568d3;
      }

      .go-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .browser-frame {
        flex: 1;
        position: relative;
        background: #000;
        border: none;
      }

      .browser-frame iframe {
        width: 100%;
        height: 100%;
        border: none;
        background: white;
      }

      .status-overlay {
        position: absolute;
        top: 1rem;
        right: 1rem;
        background: rgba(0,0,0,0.8);
        padding: 1rem 1.5rem;
        border-radius: 12px;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255,255,255,0.1);
        min-width: 250px;
      }

      .status-item {
        margin-bottom: 0.75rem;
        font-size: 0.9rem;
      }

      .status-item:last-child {
        margin-bottom: 0;
      }

      .status-label {
        opacity: 0.7;
        font-size: 0.85rem;
        margin-bottom: 0.25rem;
      }

      .status-value {
        font-weight: 600;
        color: #4ade80;
      }

      .toast {
        position: fixed;
        bottom: 2rem;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.9);
        padding: 1rem 1.5rem;
        border-radius: 12px;
        border: 2px solid rgba(255,255,255,0.2);
        backdrop-filter: blur(10px);
        z-index: 1000;
        animation: slideUp 0.3s ease-out;
        max-width: 90%;
        text-align: center;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .cooldown-indicator {
        font-size: 0.8rem;
        opacity: 0.7;
        margin-top: 0.25rem;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>üåê Browser Battle</h1>
      <div class="control-panel">
        <div class="players-list" id="players-list"></div>
        <button class="control-btn" id="take-control-btn">Take Control</button>
      </div>
    </div>

    <div class="main-content">
      <div class="url-bar">
        <input 
          type="text" 
          class="url-input" 
          id="url-input" 
          placeholder="Enter URL or search term..."
          disabled
        />
        <button class="go-btn" id="go-btn" disabled>Go</button>
      </div>
      <div class="browser-frame">
        <iframe id="browser-iframe" src="https://duckduckgo.com" sandbox="allow-same-origin allow-scripts allow-popups allow-forms"></iframe>
        <div class="status-overlay">
          <div class="status-item">
            <div class="status-label">Controller</div>
            <div class="status-value" id="controller-name">No one</div>
          </div>
          <div class="status-item">
            <div class="status-label">Players Online</div>
            <div class="status-value" id="player-count">1</div>
          </div>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const ioClient = io({
        path: '/socket.io',
        transports: ['websocket'],
        upgrade: false,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000
      });

      let myId = null;
      let players = new Map();
      let currentController = null;
      let currentUrl = 'https://duckduckgo.com';
      let isInControl = false;
      let lastIframeUrl = currentUrl;
      let playerListUpdatePending = false;

      // Cache DOM references
      const urlInput = document.getElementById('url-input');
      const goBtn = document.getElementById('go-btn');
      const takeControlBtn = document.getElementById('take-control-btn');
      const browserIframe = document.getElementById('browser-iframe');
      const playersList = document.getElementById('players-list');
      const controllerNameEl = document.getElementById('controller-name');
      const playerCountEl = document.getElementById('player-count');

      function showToast(message, duration = 3000) {
        const toast = document.createElement('div');
        toast.className = 'toast';
        toast.textContent = message;
        document.body.appendChild(toast);
        setTimeout(() => {
          toast.style.animation = 'slideUp 0.3s ease-out reverse';
          setTimeout(() => toast.remove(), 300);
        }, duration);
      }

      function updatePlayersList() {
        if (playerListUpdatePending) return;
        playerListUpdatePending = true;
        
        requestAnimationFrame(() => {
          playersList.innerHTML = '';
          const fragment = document.createDocumentFragment();
          
          players.forEach((player, id) => {
            const badge = document.createElement('div');
            badge.className = 'player-badge';
            const isController = id === currentController;
            const isMe = id === myId;
            
            if (isController) {
              badge.style.background = '#4ade8020';
              badge.style.borderColor = '#4ade80';
              badge.style.color = '#4ade80';
            } else {
              badge.style.background = player.color + '20';
              badge.style.border = `2px solid ${player.color}`;
              badge.style.color = player.color;
            }
            
            badge.innerHTML = `<span class="player-dot"></span>${player.name}${isMe ? ' (You)' : ''}${isController ? ' üëë' : ''}`;
            fragment.appendChild(badge);
          });
          
          playersList.appendChild(fragment);
          playerCountEl.textContent = players.size;
          playerListUpdatePending = false;
        });
      }

      function updateControlState() {
        isInControl = currentController === myId;
        takeControlBtn.disabled = isInControl;
        takeControlBtn.textContent = isInControl ? 'You Control' : 'Take Control';
        takeControlBtn.classList.toggle('active', isInControl);
        
        urlInput.disabled = !isInControl;
        goBtn.disabled = !isInControl;
        
        if (isInControl) {
          urlInput.focus();
          // Start monitoring iframe navigation when we gain control
          startIframeMonitoring();
        } else {
          // Stop monitoring iframe navigation when we lose control
          stopIframeMonitoring();
        }
      }

      // Monitor iframe navigation for controller (optimized)
      let iframeMonitorInterval = null;
      let lastCheckTime = 0;
      const IFRAME_CHECK_INTERVAL = 2000; // Check every 2 seconds instead of 500ms
      
      function checkIframeNavigation() {
        if (!isInControl) return;
        
        const now = Date.now();
        if (now - lastCheckTime < IFRAME_CHECK_INTERVAL) return;
        lastCheckTime = now;
        
        try {
          // Try to get iframe location (may fail due to CORS)
          const iframeDoc = browserIframe.contentDocument || browserIframe.contentWindow?.document;
          
          if (iframeDoc?.location) {
            const newUrl = iframeDoc.location.href;
            if (newUrl !== lastIframeUrl && newUrl !== currentUrl) {
              lastIframeUrl = newUrl;
              currentUrl = newUrl;
              urlInput.value = newUrl;
              ioClient.emit('iframeNavigate', { url: newUrl });
              return;
            }
          }
        } catch (e) {
          // CORS error - check iframe src as fallback
        }
        
        // Fallback: check iframe src attribute
        const srcUrl = browserIframe.src;
        if (srcUrl !== lastIframeUrl && srcUrl !== currentUrl) {
          lastIframeUrl = srcUrl;
          currentUrl = srcUrl;
          urlInput.value = srcUrl;
          ioClient.emit('iframeNavigate', { url: srcUrl });
        }
      }
      
      function startIframeMonitoring() {
        if (iframeMonitorInterval) return;
        lastCheckTime = Date.now();
        
        // Check less frequently for better performance
        iframeMonitorInterval = setInterval(checkIframeNavigation, IFRAME_CHECK_INTERVAL);
      }
      
      function stopIframeMonitoring() {
        if (iframeMonitorInterval) {
          clearInterval(iframeMonitorInterval);
          iframeMonitorInterval = null;
        }
      }
      
      // Monitor iframe load events (more efficient than polling)
      browserIframe.addEventListener('load', () => {
        if (isInControl) {
          const newUrl = browserIframe.src;
          if (newUrl !== lastIframeUrl && newUrl !== currentUrl) {
            lastIframeUrl = newUrl;
            currentUrl = newUrl;
            urlInput.value = newUrl;
            ioClient.emit('iframeNavigate', { url: newUrl });
          }
        }
      });

      // Socket events
      ioClient.on('connect', () => {
        myId = ioClient.id;
        showToast('Connected to Browser Battle!');
      });

      ioClient.on('state', (state) => {
        players.clear();
        state.players.forEach(p => players.set(p.id, p));
        currentController = state.currentController;
        currentUrl = state.currentUrl;
        browserIframe.src = currentUrl;
        urlInput.value = currentUrl;
        updatePlayersList();
        updateControlState();
      });

      ioClient.on('playerJoined', (player) => {
        players.set(player.id, player);
        updatePlayersList();
        showToast(`${player.name} joined the battle!`);
      });

      ioClient.on('playerLeft', ({ id }) => {
        const player = players.get(id);
        if (player) {
          showToast(`${player.name} left`);
        }
        players.delete(id);
        updatePlayersList();
      });

      ioClient.on('controlChanged', ({ newController, controllerName }) => {
        currentController = newController;
        const controllerPlayer = newController ? players.get(newController) : null;
        controllerNameEl.textContent = controllerPlayer ? controllerPlayer.name : 'No one';
        updatePlayersList();
        updateControlState();
        
        if (newController === myId) {
          showToast('üéâ You took control!', 2000);
        } else if (controllerPlayer) {
          showToast(`${controllerPlayer.name} took control!`);
        }
      });

      ioClient.on('controlLost', () => {
        showToast('‚ùå You lost control!', 2000);
        updateControlState();
      });

      ioClient.on('urlChanged', ({ url, controllerName }) => {
        // Skip if URL hasn't changed
        if (currentUrl === url) return;
        
        // Update URL bar for everyone
        urlInput.value = url;
        
        // Only update iframe if we're not the controller (controller already updated it)
        // This prevents loops and unnecessary reloads
        if (!isInControl) {
          currentUrl = url;
          browserIframe.src = url;
          lastIframeUrl = url;
        } else {
          // Even if we're controller, update our tracking
          currentUrl = url;
          lastIframeUrl = url;
        }
        
        // Only show toast if someone else navigated
        if (controllerName && controllerName !== players.get(myId)?.name) {
          showToast(`${controllerName} navigated to ${url}`);
        }
      });

      ioClient.on('error', ({ message }) => {
        showToast(`Error: ${message}`, 3000);
      });

      // UI events
      takeControlBtn.addEventListener('click', () => {
        if (!isInControl) {
          ioClient.emit('takeControl');
        }
      });

      // URL validation helper
      function validateUrl(url) {
        let validatedUrl = String(url || '').trim();
        if (!validatedUrl) return null;
        if (!validatedUrl.startsWith('http://') && !validatedUrl.startsWith('https://')) {
          validatedUrl = 'https://' + validatedUrl;
        }
        try {
          new URL(validatedUrl);
          return validatedUrl;
        } catch (e) {
          return null;
        }
      }

      goBtn.addEventListener('click', () => {
        if (!isInControl) return;
        
        const url = urlInput.value.trim();
        if (!url) return;
        
        const validatedUrl = validateUrl(url);
        if (!validatedUrl) {
          showToast('Invalid URL', 2000);
          return;
        }
        
        // Update local iframe immediately
        currentUrl = validatedUrl;
        browserIframe.src = validatedUrl;
        lastIframeUrl = validatedUrl;
        // Broadcast to others
        ioClient.emit('navigate', { url: validatedUrl });
      });

      urlInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && isInControl) {
          goBtn.click();
        }
      });
      
      // Cleanup on page unload
      window.addEventListener('beforeunload', () => {
        stopIframeMonitoring();
      });
    </script>
  </body>
  </html>
