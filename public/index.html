<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Oct30 Express Server</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; margin: 0; display: grid; place-items: center; min-height: 100svh; }
      .card { padding: 2rem; text-align: center; max-width: 680px; }
      h1 { margin: 0 0 0.5rem; font-size: clamp(1.75rem, 2.5vw + 1rem, 3rem); }
      p { margin: 0.5rem 0; line-height: 1.5; }
      code { padding: 0.2rem 0.4rem; border-radius: 4px; background: color-mix(in oklab, canvas 92%, black); }
      a { color: inherit; }
    </style>
  </head>
  <body>
    <main class="card">
      <h1>Multiplayer Animals</h1>
      <p>Move with WASD. Open this page in multiple tabs to see others.</p>
      <canvas id="game" width="960" height="540" style="max-width: 100%; border-radius: 12px; background: color-mix(in oklab, canvas 96%, black);"></canvas>
      <p>Health check: <a href="/health">/health</a></p>
    </main>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const ioClient = io({
        path: '/socket.io',
        transports: ['websocket'],
        upgrade: false,
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 5000,
        timeout: 20000
      });

      const world = { width: 2000, height: 1200 };
      const camera = { x: 0, y: 0, w: canvas.width, h: canvas.height };
      const keys = new Set();
      const players = new Map(); // id -> { x, y, animal, chips }
      const tables = { roulette: null, blackjack: null };
      let activePanel = null; // 'roulette' | 'blackjack' | null

      // UI overlay elements
      const ui = document.createElement('div');
      ui.style.position = 'fixed';
      ui.style.inset = 'auto 1rem 1rem auto';
      ui.style.padding = '1rem';
      ui.style.borderRadius = '12px';
      ui.style.background = 'color-mix(in oklab, canvas 92%, black)';
      ui.style.boxShadow = '0 6px 24px rgba(0,0,0,.2)';
      ui.style.minWidth = '280px';
      ui.style.maxWidth = '90vw';
      ui.style.display = 'none';
      document.body.appendChild(ui);
      let myId = null;

      function resize() {
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width * dpr);
        canvas.height = Math.floor((rect.width * 9/16) * dpr);
        camera.w = canvas.width; camera.h = canvas.height;
      }
      window.addEventListener('resize', resize);
      resize();

      // Socket handlers
      ioClient.on('connect', () => { myId = ioClient.id; });
      ioClient.on('reconnect', () => { /* state will resync via server 'state' or movement */ });
      ioClient.on('connect_error', (err) => { console.warn('connect_error', err?.message || err); });
      ioClient.on('state', (obj) => {
        players.clear();
        for (const [id, p] of Object.entries(obj)) players.set(id, p);
        if (!myId) myId = ioClient.id;
      });
      ioClient.on('chipsUpdate', ({ id, chips }) => {
        const p = players.get(id);
        if (p) { p.chips = chips; }
        if (id === myId) drawHUD();
      });
      ioClient.on('tablesState', (state) => {
        tables.roulette = state.roulette;
        tables.blackjack = { ...state.blackjack };
        renderUI();
      });
      ioClient.on('rouletteUpdate', (r) => { tables.roulette = r; renderUI(); });
      ioClient.on('rouletteSpin', ({ result, wins }) => {
        tables.roulette.lastResult = result;
        renderUI();
      });
      ioClient.on('blackjackUpdate', (bj) => { tables.blackjack = bj; renderUI(); });
      ioClient.on('blackjackResolve', ({ dealer, results }) => {
        // Brief flash effect could be added; for now just re-render
        renderUI();
      });
      ioClient.on('playerJoined', (p) => { players.set(p.id, { x: p.x, y: p.y, animal: p.animal }); });
      ioClient.on('playerMoved', ({ id, x, y }) => { const p = players.get(id); if (p) { p.x = x; p.y = y; } });
      ioClient.on('playerLeft', ({ id }) => { players.delete(id); });

      // Input
      window.addEventListener('keydown', (e) => { if ('wasd'.includes(e.key.toLowerCase())) { keys.add(e.key.toLowerCase()); e.preventDefault(); }});
      window.addEventListener('keyup', (e) => { if ('wasd'.includes(e.key.toLowerCase())) { keys.delete(e.key.toLowerCase()); e.preventDefault(); }});

      let last = performance.now();
      function loop(now) {
        const dt = Math.min(0.1, (now - last) / 1000);
        last = now;

        let vx = 0, vy = 0;
        if (keys.has('w')) vy -= 1;
        if (keys.has('s')) vy += 1;
        if (keys.has('a')) vx -= 1;
        if (keys.has('d')) vx += 1;
        // normalize diagonal
        if (vx !== 0 && vy !== 0) { const inv = 1/Math.sqrt(2); vx *= inv; vy *= inv; }

        if ((vx !== 0 || vy !== 0) && myId) {
          ioClient.emit('move', { vx, vy, dt });
        }

        // center camera on self
        const me = myId ? players.get(myId) : null;
        if (me) {
          camera.x = Math.round(me.x - camera.w / 2);
          camera.y = Math.round(me.y - camera.h / 2);
          camera.x = Math.max(0, Math.min(world.width - camera.w, camera.x));
          camera.y = Math.max(0, Math.min(world.height - camera.h, camera.y));
        }

        draw();
        requestAnimationFrame(loop);
      }

      function drawGrid() {
        const step = 100;
        ctx.strokeStyle = 'rgba(127,127,127,0.25)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = -camera.x % step; x < camera.w; x += step) {
          ctx.moveTo(x, 0); ctx.lineTo(x, camera.h);
        }
        for (let y = -camera.y % step; y < camera.h; y += step) {
          ctx.moveTo(0, y); ctx.lineTo(camera.w, y);
        }
        ctx.stroke();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawCasinoFloor();

        // Draw tables
        if (tables.roulette) drawRouletteTable();
        if (tables.blackjack) drawBlackjackTable();

        for (const [id, p] of players) {
          const screenX = Math.round(p.x - camera.x);
          const screenY = Math.round(p.y - camera.y);
          const size = 36;
          ctx.font = `${size}px system-ui, emoji`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(p.animal || '🐾', screenX, screenY);

          if (id === myId) {
            ctx.strokeStyle = 'deepskyblue';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(screenX, screenY, 24, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }

      requestAnimationFrame(loop);

      function drawCasinoFloor() {
        // floor pattern
        const step = 80;
        ctx.fillStyle = 'color-mix(in oklab, canvas 94%, black)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'rgba(0,0,0,0.05)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let x = -camera.x % step; x < camera.w; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, camera.h); }
        for (let y = -camera.y % step; y < camera.h; y += step) { ctx.moveTo(0, y); ctx.lineTo(camera.w, y); }
        ctx.stroke();

        // rooms (simple rectangles)
        drawRoom(450, 350, 400, 300); // Roulette room
        drawRoom(1000, 400, 500, 320); // Blackjack room
      }

      function drawRoom(cx, cy, w, h) {
        const x = cx - camera.x - w/2;
        const y = cy - camera.y - h/2;
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
        ctx.lineWidth = 4;
        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);
      }

      function drawRouletteTable() {
        const t = tables.roulette;
        const x = t.x - camera.x, y = t.y - camera.y;
        ctx.fillStyle = 'rgba(0,128,0,0.8)';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.fillRect(x - 100, y - 50, 200, 100);
        ctx.strokeRect(x - 100, y - 50, 200, 100);
        ctx.fillStyle = 'white';
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Roulette', x, y - 20);
        const secs = Math.max(0, Math.ceil((t.nextSpinAt - Date.now()) / 1000));
        ctx.fillText(`Spin in ${secs}s`, x, y + 10);
        if (t.lastResult !== null) ctx.fillText(`Last: ${t.lastResult}`, x, y + 35);
      }

      function drawBlackjackTable() {
        const t = tables.blackjack;
        const x = t.x - camera.x, y = t.y - camera.y;
        ctx.fillStyle = 'rgba(0,64,160,0.8)';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.fillRect(x - 120, y - 60, 240, 120);
        ctx.strokeRect(x - 120, y - 60, 240, 120);
        ctx.fillStyle = 'white';
        ctx.font = '20px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Blackjack', x, y - 10);
        ctx.fillText(`${t.roundActive ? 'Round active' : 'Place bets'}`, x, y + 20);
      }

      // Click to open UI if close to a table
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const dpr = Math.min(2, window.devicePixelRatio || 1);
        const cx = (e.clientX - rect.left) * dpr + camera.x;
        const cy = (e.clientY - rect.top) * dpr + camera.y;
        const me = myId ? players.get(myId) : null;
        if (!me) return;
        const near = (px, py) => (Math.hypot(me.x - px, me.y - py) < 150);
        if (tables.roulette && near(tables.roulette.x, tables.roulette.y)) { activePanel = 'roulette'; renderUI(); return; }
        if (tables.blackjack && near(tables.blackjack.x, tables.blackjack.y)) { activePanel = 'blackjack'; renderUI(); return; }
      });

      function renderUI() {
        if (!activePanel) { ui.style.display = 'none'; ui.innerHTML = ''; return; }
        ui.style.display = 'block';
        if (activePanel === 'roulette') renderRouletteUI();
        else if (activePanel === 'blackjack') renderBlackjackUI();
      }

      function renderRouletteUI() {
        const t = tables.roulette;
        const secs = Math.max(0, Math.ceil((t.nextSpinAt - Date.now()) / 1000));
        ui.innerHTML = `
          <h3 style="margin:0 0 .5rem">Roulette</h3>
          <div style="font-size:.9rem; opacity:.8; margin-bottom:.5rem">Spin in ${secs}s${t.lastResult !== null ? ` • Last: ${t.lastResult}` : ''}</div>
          <div id="chips" style="font-size:.9rem; margin-bottom:.5rem"></div>
          <form id="r-form" style="display:flex; gap:.5rem; align-items:center; margin-bottom:.5rem">
            <label>Number <input id="r-num" type="number" min="0" max="36" style="width:5rem"></label>
            <label>Amount <input id="r-amt" type="number" min="1" max="1000" style="width:6rem"></label>
            <button type="submit">Bet</button>
          </form>
          <button id="r-close">Close</button>
        `;
        ui.querySelector('#r-close').onclick = () => { activePanel = null; renderUI(); };
        ui.querySelector('#r-form').onsubmit = (ev) => {
          ev.preventDefault();
          const number = Number(ui.querySelector('#r-num').value);
          const amount = Number(ui.querySelector('#r-amt').value);
          const me = myId ? players.get(myId) : null;
          if (!me || (me.chips ?? 0) < amount) { alert('Insufficient chips'); return; }
          ioClient.emit('roulette:bet', { number, amount });
        };
        const me = myId ? players.get(myId) : null;
        if (me) ui.querySelector('#chips').textContent = `Your chips: $${me.chips ?? 0}`;
      }

      function renderBlackjackUI() {
        const t = tables.blackjack;
        const me = myId ? (t.players || []).find(p => p.id === myId) : null;
        const dealerVal = (t.dealer || []).length ? `Dealer: ${t.dealer.join(' ')} (${value(t.dealer)})` : 'Dealer: (waiting)';
        const myVal = me ? `You: ${me.hand.join(' ')} (${value(me.hand)})` : 'You: (no bet)';
        const canBet = !t.roundActive;
        ui.innerHTML = `
          <h3 style="margin:0 0 .5rem">Blackjack</h3>
          <div style="font-size:.9rem; opacity:.8; margin-bottom:.5rem">${dealerVal}<br>${myVal}</div>
          <div id="chips" style="font-size:.9rem; margin-bottom:.5rem"></div>
          <div id="bj-actions" style="display:flex; gap:.5rem; flex-wrap:wrap; margin-bottom:.5rem"></div>
          <button id="bj-close">Close</button>
        `;
        ui.querySelector('#bj-close').onclick = () => { activePanel = null; renderUI(); };
        const actions = ui.querySelector('#bj-actions');
        if (canBet) {
          const betWrap = document.createElement('div');
          betWrap.innerHTML = '<label>Bet <input id="bj-bet" type="number" min="1" max="1000" style="width:6rem"></label>';
          const betBtn = document.createElement('button'); betBtn.textContent = 'Place Bet';
          betBtn.onclick = () => {
            const amount = Number(ui.querySelector('#bj-bet').value);
            const mep = myId ? players.get(myId) : null;
            if (!mep || (mep.chips ?? 0) < amount) { alert('Insufficient chips'); return; }
            ioClient.emit('blackjack:bet', { amount });
          };
          const dealBtn = document.createElement('button'); dealBtn.textContent = 'Deal'; dealBtn.onclick = () => ioClient.emit('blackjack:deal');
          actions.append(betWrap, betBtn, dealBtn);
        } else if (me) {
          const hit = document.createElement('button'); hit.textContent = 'Hit'; hit.onclick = () => ioClient.emit('blackjack:hit');
          const stand = document.createElement('button'); stand.textContent = 'Stand'; stand.onclick = () => ioClient.emit('blackjack:stand');
          actions.append(hit, stand);
        }
        const self = myId ? players.get(myId) : null;
        if (self) ui.querySelector('#chips').textContent = `Your chips: $${self.chips ?? 0}`;

        function value(cards) {
          if (!cards || !cards.length) return 0;
          // simple mirror of server handValue
          let total = 0, aces = 0;
          for (const c of cards) {
            const r = c.replace(/[♠♥♦♣]/g, '');
            if (r === 'A') { total += 11; aces++; }
            else if (['K','Q','J','10'].includes(r)) total += 10;
            else total += Number(r);
          }
          while (total > 21 && aces > 0) { total -= 10; aces--; }
          return total;
        }
      }

      // HUD for chips
      const hud = document.createElement('div');
      hud.style.position = 'fixed';
      hud.style.left = '1rem';
      hud.style.top = '1rem';
      hud.style.padding = '.5rem .75rem';
      hud.style.borderRadius = '999px';
      hud.style.background = 'color-mix(in oklab, canvas 92%, black)';
      hud.style.boxShadow = '0 6px 24px rgba(0,0,0,.2)';
      hud.style.fontWeight = '600';
      document.body.appendChild(hud);
      function drawHUD() {
        const me = myId ? players.get(myId) : null;
        hud.textContent = me ? `Chips: $${me.chips ?? 0}` : 'Chips: --';
      }
      setInterval(drawHUD, 500);
    </script>
  </body>
  </html>


